################################################################################
# Changed version of liquidprompt
# Full version: https://github.com/nojhan/liquidprompt
################################################################################
# LIQUID PROMPT
# An intelligent and non intrusive prompt for bash and zsh
################################################################################
#
# Licensed under the AGPL version 3
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

###########
# AUTHORS #
###########

# Alex Prengère     <alexprengere@gmail.com>      # Untracked git files
# Anthony Gelibert  <anthony.gelibert@me.com>     # Several fix
# Aurelien Requiem  <aurelien@requiem.fr>         # Major clean refactoring, variable path length, error codes, several bugfixes.
# Brendan Fahy      <bmfahy@gmail.com>            # Postfix variable
# Clément Mathieu   <clement@unportant.info>      # Bazaar support
# David Loureiro    <david.loureiro@sysfera.com>  # Small portability fix
# Étienne Deparis   <etienne@depar.is>            # Fossil support
# Florian Le Frioux <florian@lefrioux.fr>         # Use ± mark when root in VCS dir.
# François Schmidts <francois.schmidts@gmail.com> # Small code fix, _lp_get_dirtrim
# Frédéric Lepied   <flepied@gmail.com>           # Python virtual env
# Jonas Bengtsson   <jonas.b@gmail.com>           # Git remotes fix
# Joris Dedieu      <joris@pontiac3.nfrance.com>  # Portability framework, FreeBSD support, bugfixes.
# Joris Vaillant    <joris.vaillant@gmail.com>    # Small git fix
# Luc Didry         <luc@fiat-tux.fr>             # ZSH port, several fix
# Ludovic Rousseau  <ludovic.rousseau@gmail.com>  # Lot of bugfixes.
# Markus Dreseler   <github@dreseler.de>          # Runtime of last command
# Nicolas Lacourte  <nicolas@dotinfra.fr>         # Screen title
# nojhan            <nojhan@gmail.com>            # Original author.
# Olivier Mengué    <dolmen@cpan.org>             # Major optimizations, refactorings everywhere; current maintainer
# Poil              <poil@quake.fr>               # Speed improvements
# Thomas Debesse    <thomas.debesse@gmail.com>    # Fix columns use.
# Yann 'Ze' Richard <ze@nbox.org>                 # Do not fail on missing commands.

# Check for recent enough version of bash.
if test -n "$BASH_VERSION" ; then
    _LP_SHELL_bash=true
    _LP_OPEN_ESC="\["
    _LP_CLOSE_ESC="\]"
    _LP_USER_SYMBOL="\u"
    _LP_HOST_SYMBOL="\h"
    _LP_TIME_SYMBOL="\A"      #t for seconds
    _LP_MARK_SYMBOL='\$'
elif test -n "$ZSH_VERSION" ; then
    _LP_SHELL_bash=false
    _LP_OPEN_ESC="%{"
    _LP_CLOSE_ESC="%}"
    _LP_USER_SYMBOL="%n"
    _LP_HOST_SYMBOL="%m"
    _LP_TIME_SYMBOL="%D{%R}"  #%D{%T} for seconds
    _LP_MARK_SYMBOL='%(!.#.%%)'
else
    echo "liquidprompt: shell not supported" >&2
    return
fi


#################
# CONFIGURATION #
#################

_lp_source_config()
{
    # TermInfo feature detection
    local ti_sgr0="$(tput sgr0 2>/dev/null)"
    local ti_bold="$(tput bold 2>/dev/null)"
    local ti_setaf
    local ti_setab
    if tput setaf >/dev/null 2>&1 ; then
        ti_setaf () { tput setaf "$1" ; }
    else
        echo "liquidprompt: terminal $TERM not supported" >&2
        ti_setaf () { : ; }
    fi
    if tput setab >/dev/null 2>&1 ; then
        ti_setab () { tput setab "$1" ; }
    else
        echo "liquidprompt: terminal $TERM not supported" >&2
        ti_setab () { : ; }
    fi

    # Colors: variables are local so they will have a value only
    # during config loading and will not conflict with other values
    # with the same names defined by the user outside the config.
    local BOLD="${_LP_OPEN_ESC}${ti_bold}${_LP_CLOSE_ESC}"

    local BLACK="${_LP_OPEN_ESC}$(ti_setaf 0)${_LP_CLOSE_ESC}"
    local BOLD_GRAY="${_LP_OPEN_ESC}${ti_bold}$(ti_setaf 0)${_LP_CLOSE_ESC}"
    local WHITE="${_LP_OPEN_ESC}$(ti_setaf 7)${_LP_CLOSE_ESC}"
    local BOLD_WHITE="${_LP_OPEN_ESC}${ti_bold}$(ti_setaf 7)${_LP_CLOSE_ESC}"

    local RED="${_LP_OPEN_ESC}$(ti_setaf 1)${_LP_CLOSE_ESC}"
    local BOLD_RED="${_LP_OPEN_ESC}${ti_bold}$(ti_setaf 1)${_LP_CLOSE_ESC}"
    local WARN_RED="${_LP_OPEN_ESC}$(ti_setaf 0 ; ti_setab 1)${_LP_CLOSE_ESC}"
    local CRIT_RED="${_LP_OPEN_ESC}${ti_bold}$(ti_setaf 7 ; ti_setab 1)${_LP_CLOSE_ESC}"
    local DANGER_RED="${_LP_OPEN_ESC}${ti_bold}$(ti_setaf 3 ; ti_setab 1)${_LP_CLOSE_ESC}"

    local GREEN="${_LP_OPEN_ESC}$(ti_setaf 2)${_LP_CLOSE_ESC}"
    local BOLD_GREEN="${_LP_OPEN_ESC}${ti_bold}$(ti_setaf 2)${_LP_CLOSE_ESC}"

    local YELLOW="${_LP_OPEN_ESC}$(ti_setaf 3)${_LP_CLOSE_ESC}"
    local BOLD_YELLOW="${_LP_OPEN_ESC}${ti_bold}$(ti_setaf 3)${_LP_CLOSE_ESC}"

    local BLUE="${_LP_OPEN_ESC}$(ti_setaf 4)${_LP_CLOSE_ESC}"
    local BOLD_BLUE="${_LP_OPEN_ESC}${ti_bold}$(ti_setaf 4)${_LP_CLOSE_ESC}"

    local PURPLE="${_LP_OPEN_ESC}$(ti_setaf 5)${_LP_CLOSE_ESC}"
    local PINK="${_LP_OPEN_ESC}${ti_bold}$(ti_setaf 5)${_LP_CLOSE_ESC}"

    local CYAN="${_LP_OPEN_ESC}$(ti_setaf 6)${_LP_CLOSE_ESC}"
    local BOLD_CYAN="${_LP_OPEN_ESC}${ti_bold}$(ti_setaf 6)${_LP_CLOSE_ESC}"

    # NO_COL is special: it will be used at runtime, not just during config loading
    NO_COL="${_LP_OPEN_ESC}${ti_sgr0}${_LP_CLOSE_ESC}"

    unset ti_sgr0 ti_bold ti_setaf ti_setab

    LP_TITLE_OPEN="\e]0;"
    LP_TITLE_CLOSE="\a"
    LP_SCREEN_TITLE_OPEN="\033k"
    LP_SCREEN_TITLE_CLOSE="\033\\\\"

    LP_ENABLE_PERM=1
    LP_ENABLE_SHORTEN_PATH=1
    LP_ENABLE_PROXY=0
    LP_ENABLE_JOBS=1
    LP_ENABLE_VCS_ROOT=0
    LP_ENABLE_GIT=1
    LP_ENABLE_TIME=0
    LP_ENABLE_VIRTUALENV=1
    LP_ENABLE_TITLE=1
    LP_ENABLE_SCREEN_TITLE=1

    LP_HOSTNAME_ALWAYS=0
    LP_USER_ALWAYS=0
    LP_PATH_LENGTH=35
    LP_PATH_KEEP=2

    LP_DISABLED_VCS_PATH=""
    LP_PS1_PREFIX=""
    LP_PS1_POSTFIX=" "

    LP_MARK_PROXY="↥"
    LP_MARK_GIT="±"
    LP_MARK_DISABLED="⌀"
    LP_MARK_UNTRACKED="*"
    LP_MARK_STASH="+"
    LP_MARK_BRACKET_OPEN="["
    LP_MARK_BRACKET_CLOSE="]"
    LP_MARK_SHORTEN_PATH=" … "
    LP_MARK_PREFIX=" "

    LP_COLOR_PATH=$BOLD
    LP_COLOR_PATH_ROOT=$BOLD_YELLOW
    LP_COLOR_PROXY=$BOLD_BLUE
    LP_COLOR_JOB_D=$YELLOW
    LP_COLOR_JOB_R=$BOLD_YELLOW
    LP_COLOR_JOB_Z=$BOLD_YELLOW
    LP_COLOR_ERR=$PURPLE
    LP_COLOR_MARK=$BOLD
    LP_COLOR_MARK_ROOT=$BOLD_RED
    LP_COLOR_USER_LOGGED=""
    LP_COLOR_USER_ALT=$BOLD
    LP_COLOR_USER_ROOT=$BOLD_YELLOW
    LP_COLOR_HOST=""
    LP_COLOR_SSH=$BLUE
    LP_COLOR_SU=$BOLD_YELLOW
    LP_COLOR_TELNET=$WARN_RED
    LP_COLOR_X11_ON=$GREEN
    LP_COLOR_X11_OFF=$YELLOW
    LP_COLOR_WRITE=$GREEN
    LP_COLOR_NOWRITE=$RED
    LP_COLOR_UP=$GREEN
    LP_COLOR_COMMITS=$YELLOW
    LP_COLOR_CHANGES=$RED
    LP_COLOR_DIFF=$PURPLE
    LP_COLOR_TIME=$BLUE
    LP_COLOR_IN_MULTIPLEXER=$BOLD_BLUE
    LP_COLOR_VIRTUALENV=$CYAN
}
# do source config files
_lp_source_config
unset _lp_source_config

# Disable features if the tool is not installed
[[ "$LP_ENABLE_GIT" = 1 ]] && { command -v git >/dev/null || LP_ENABLE_GIT=0 ; }

# If we are running in a terminal multiplexer, brackets are colored
if [[ "$TERM" == screen* ]]; then
    LP_BRACKET_OPEN="${LP_COLOR_IN_MULTIPLEXER}${LP_MARK_BRACKET_OPEN}${NO_COL}"
    LP_BRACKET_CLOSE="${LP_COLOR_IN_MULTIPLEXER}${LP_MARK_BRACKET_CLOSE}${NO_COL}"
else
    LP_BRACKET_OPEN="${LP_MARK_BRACKET_OPEN}"
    LP_BRACKET_CLOSE="${LP_MARK_BRACKET_CLOSE}"
fi


###############
# Who are we? #
###############

# Yellow for root, bold if the user is not the login one, else no color.
if [[ "$EUID" -ne "0" ]] ; then  # if user is not root
    # if user is not login user
    if [[ ${USER} != "$(logname 2>/dev/null || echo $LOGNAME)" ]]; then
        LP_USER="${LP_COLOR_USER_ALT}${_LP_USER_SYMBOL}${NO_COL}"
    else
        if [[ "${LP_USER_ALWAYS}" -ne "0" ]] ; then
            LP_USER="${LP_COLOR_USER_LOGGED}${_LP_USER_SYMBOL}${NO_COL}"
        else
            LP_USER=""
        fi
    fi
else # root!
    LP_USER="${LP_COLOR_USER_ROOT}${_LP_USER_SYMBOL}${NO_COL}"
    LP_COLOR_MARK="${LP_COLOR_MARK_ROOT}"
    LP_COLOR_PATH="${LP_COLOR_PATH_ROOT}"
    # Disable VCS info for all paths
    if [[ "$LP_ENABLE_VCS_ROOT" != 1 ]]; then
        LP_DISABLED_VCS_PATH=/
        LP_MARK_DISABLED="$_LP_MARK_SYMBOL"
    fi
fi


#################
# Where are we? #
#################

_lp_connection()
{
    if [[ -n "$SSH_CLIENT$SSH2_CLIENT$SSH_TTY" ]] ; then
        echo ssh
    else
        local sess_src="$(who am i | sed -n 's/.*(\(.*\))/\1/p')"
        local sess_parent="$(ps -o comm= -p $PPID 2> /dev/null)"
        if [[ -z "$sess_src" || "$sess_src" = ":"* ]] ; then
            echo lcl  # Local
        elif [[ "$sess_parent" = "su" || "$sess_parent" = "sudo" ]] ; then
            echo su   # Remote su/sudo
        else
            echo tel  # Telnet
        fi
    fi
}

# Put the hostname if not locally connected
# color it in cyan within SSH, and a warning red if within telnet
# else diplay the host without color
# The connection is not expected to change from inside the shell, so we
# build this just once
LP_HOST=""
_chroot()
{
    if [[ -r /etc/debian_chroot ]] ; then
        local debchroot
        debchroot="$(cat /etc/debian_chroot)"
        echo "(${debchroot})"
    fi
}
LP_HOST="$(_chroot)"
unset _chroot

# If we are connected with a X11 support
if [[ -n "$DISPLAY" ]] ; then
    LP_HOST="${LP_COLOR_X11_ON}${LP_HOST}@${NO_COL}"
else
    LP_HOST="${LP_COLOR_X11_OFF}${LP_HOST}@${NO_COL}"
fi

case "$(_lp_connection)" in
lcl)
    if [[ "${LP_HOSTNAME_ALWAYS}" -eq "0" ]] ; then
        # FIXME do we want to display the chroot if local?
        LP_HOST="" # no hostname if local
    else
        LP_HOST="${LP_HOST}${LP_COLOR_HOST}${_LP_HOST_SYMBOL}${NO_COL}"
    fi
    ;;
ssh)
    LP_HOST="${LP_HOST}${LP_COLOR_SSH}${_LP_HOST_SYMBOL}${NO_COL}"
    ;;
su)
    LP_HOST="${LP_HOST}${LP_COLOR_SU}${_LP_HOST_SYMBOL}${NO_COL}"
    ;;
tel)
    LP_HOST="${LP_HOST}${LP_COLOR_TELNET}${_LP_HOST_SYMBOL}${NO_COL}"
    ;;
*)
    LP_HOST="${LP_HOST}${_LP_HOST_SYMBOL}" # defaults to no color
    ;;
esac

# Useless now, so undefine
unset _lp_connection


# Shorten the path of the current working directory
# * Show only the current directory
# * Show as much of the cwd path as possible, if shortened display a
#   leading mark, such as ellipses, to indicate that part is missing
# * show at least LP_PATH_KEEP leading dirs and current directory
_lp_shorten_path()
{
    if [[ "$LP_ENABLE_SHORTEN_PATH" != 1 ]] ; then
        if $_LP_SHELL_bash; then
            echo "\\w"
        else
            print -P '%~'
        fi
        return
    fi

    local ret=""

    local p="${PWD/#$HOME/~}"
    local mask="${LP_MARK_SHORTEN_PATH}"
    local -i max_len=$(( ${COLUMNS:-80} * $LP_PATH_LENGTH / 100 ))

    if [[ ${LP_PATH_KEEP} == -1 ]]; then
        # only show the current directory, excluding any parent dirs
        ret="${p##*/}" # discard everything upto and including the last slash
        [[ "${ret}" == "" ]] && ret="/" # if in root directory
    elif (( ${#p} <= ${max_len} )); then
        ret="${p}"
    elif [[ ${LP_PATH_KEEP} == 0 ]]; then
        # len is over max len, show as much of the tail as is allowed
        ret="${p##*/}" # show at least complete current directory
        p="${p:0:${#p} - ${#ret}}"
        ret="${mask}${p:${#p} - (${max_len} - ${#ret} - ${#mask})}${ret}"
    else
        # len is over max len, show at least LP_PATH_KEEP leading dirs and
        # current directory
        local tmp=${p//\//}
        local -i delims=$(( ${#p} - ${#tmp} ))

        for (( dir=0; dir < ${LP_PATH_KEEP}; dir++ )); do
            (( ${dir} == ${delims} )) && break

            local left="${p#*/}"
            local name="${p:0:${#p} - ${#left}}"
            p="${left}"
            ret="${ret}${name%/}/"
        done

        if (( ${delims} <= ${LP_PATH_KEEP} )); then
            # no dirs between LP_PATH_KEEP leading dirs and current dir
            ret="${ret}${p##*/}"
        else
            local base="${p##*/}"

            p="${p:0:${#p} - ${#base}}"

            [[ ${ret} != "/" ]] && ret="${ret%/}" # strip trailing slash

            local -i len_left=$(( ${max_len} - ${#ret} - ${#base} - ${#mask} ))

            ret="${ret}${mask}${p:${#p} - ${len_left}}${base}"
        fi
    fi

    echo "${ret}"
}

# Display a ":"
# colored in green if user have write permission on the current directory
# colored in red if it have not.
_lp_permissions_color()
{
    if [[ "$LP_ENABLE_PERM" != 1 ]]; then
        echo : # without color
    else
        if [[ -w "${PWD}" ]]; then
            echo "${LP_COLOR_WRITE}:${NO_COL}"
        else
            echo "${LP_COLOR_NOWRITE}:${NO_COL}"
        fi
    fi
}

# Display the current Python virtual environnement, if available.
_lp_virtualenv()
{
    [[ "$LP_ENABLE_VIRTUALENV" != 1 ]] && return
    if [[ -n "$VIRTUAL_ENV" ]]; then
        echo "[${LP_COLOR_VIRTUALENV}$(basename $VIRTUAL_ENV)${NO_COL}]"
    fi
}


################
# Related jobs #
################

# Display the count of each if non-zero:
# - detached screens sessions and/or tmux sessions running on the host
# - attached running jobs (started with $ myjob &)
# - attached stopped jobs (suspended with Ctrl-Z)
_lp_jobcount_color()
{
    [[ "$LP_ENABLE_JOBS" != 1 ]] && return

    local jobs_all="$(jobs)"
    local running=$(echo "$jobs_all" | grep -c 'running')
    local stopped=$(echo "$jobs_all" | grep -c 'suspended')
    local detached=$(screen -ls 2> /dev/null | grep -c '[Dd]etach[^)]*)$')
    local m_detached="d"
    local m_stop="z"
    local m_run="&"
    local ret=""

    if [[ $detached != "0" ]] ; then
        ret="${ret}${LP_COLOR_JOB_D}${detached}${m_detached}${NO_COL}"
    fi

    if [[ $running != "0" ]] ; then
        if [[ $ret != "" ]] ; then ret="${ret}/"; fi
        ret="${ret}${LP_COLOR_JOB_R}${running}${m_run}${NO_COL}"
    fi

    if [[ $stopped != "0" ]] ; then
        if [[ $ret != "" ]] ; then ret="${ret}/"; fi
        ret="${ret}${LP_COLOR_JOB_Z}${stopped}${m_stop}${NO_COL}"
    fi

    echo -ne "$ret"
}


######################
# VCS branch display #
######################

_lp_are_vcs_enabled()
{
    [[ -z "$LP_DISABLED_VCS_PATH" ]] && return 0
    local path
    local IFS=:
    for path in $LP_DISABLED_VCS_PATH; do
        [[ "$PWD" == *"$path"* ]] && return 1
    done
    return 0
}

# GIT #

# Get the branch name of the current directory
_lp_git_branch()
{
    [[ "$LP_ENABLE_GIT" != 1 ]] && return
    [[ -z "$(\git rev-parse --is-inside-work-tree 2>/dev/null)" ]] && return
    local branch
    # Recent versions of Git support the --short option for symbolic-ref, but
    # not 1.7.9 (Ubuntu 12.04)
    if branch="$(\git symbolic-ref -q HEAD)"; then
        printf "%q" "${branch#refs/heads/}"
    else
        # In detached head state, use commit instead
        # No escape needed
        \git rev-parse --short -q HEAD
    fi
}

# Set a color depending on the branch state:
# - green if the repository is up to date
# - yellow if there is some commits not pushed
# - red if there is changes to commit
#
# Add the number of pending commits and the impacted lines.
_lp_git_branch_color()
{
    [[ "$LP_ENABLE_GIT" != 1 ]] && return

    local branch
    branch="$(_lp_git_branch)"
    if [[ -n "$branch" ]] ; then

        local end
        end="$NO_COL"
        if LC_ALL=C \git status 2>/dev/null | grep -q '\(# Untracked\)'; then
            end="$LP_COLOR_CHANGES$LP_MARK_UNTRACKED$end"
        fi

        if [[ -n "$(\git stash list 2>/dev/null)" ]]; then
            end="$LP_COLOR_COMMITS$LP_MARK_STASH$end"
        fi

        local remote
        remote="$(\git config --get branch.${branch}.remote 2>/dev/null)"

        local has_commit
        has_commit=0
        if [[ -n "$remote" ]] ; then
            local remote_branch
            remote_branch="$(\git config --get branch.${branch}.merge)"
            if [[ -n "$remote_branch" ]] ; then
                has_commit="$(\git rev-list --no-merges --count ${remote_branch/refs\/heads/refs\/remotes\/$remote}..HEAD 2>/dev/null)"
                if [[ -z "$has_commit" ]] ; then
                    has_commit=0
                fi
            fi
        fi

        local shortstat
        local ret
        shortstat="$(LC_ALL=C \git diff --shortstat HEAD 2>/dev/null)"
        if [[ -n "$shortstat" ]] ; then
            shortstat="$(LC_ALL=C \git diff --shortstat 2>/dev/null)"

            if [[ -n "$shortstat" ]] ; then
                local has_lines
                has_lines=${shortstat/*changed, /}
                has_lines=${has_lines/ inser*, /\/-}
                has_lines=${has_lines/ del*/}
                [[ "$shortstat" = *insertion* ]] && has_lines="+${has_lines/ inser*/}" || has_lines="-$has_lines"

                if [[ "$has_commit" -gt "0" ]] ; then
                    # Changes to commit and commits to push
                    ret="${LP_COLOR_CHANGES}${branch}${NO_COL}(${LP_COLOR_DIFF}$has_lines${NO_COL},${LP_COLOR_COMMITS}$has_commit${NO_COL})"
                else
                    ret="${LP_COLOR_CHANGES}${branch}${NO_COL}(${LP_COLOR_DIFF}$has_lines${NO_COL})" # changes to commit
                fi
            elif [[ "$has_commit" -gt "0" ]] ; then
                # some commit(s) to push
                ret="${LP_COLOR_CHANGES}${branch}${NO_COL}(${LP_COLOR_COMMITS}$has_commit${NO_COL})"
            else
                ret="${LP_COLOR_CHANGES}${branch}"
            fi
        elif [[ "$has_commit" -gt "0" ]] ; then
            # some commit(s) to push
            ret="${LP_COLOR_COMMITS}${branch}${NO_COL}(${LP_COLOR_COMMITS}$has_commit${NO_COL})"
        else
            ret="${LP_COLOR_UP}${branch}" # nothing to commit or push
        fi
        echo -ne "$ret$end"
    fi
}


##########
# DESIGN #
##########

# Remove all colors and escape characters of the given string and return a pure text
_lp_as_text()
{
    # Remove colors from the computed prompt
    local pst="$(echo $1 | sed -r "s/\x1B\[([0-9]+(;[0-9]+)*)?[m|K]//g")"

    # Remove bold sequences and shift in characters
    pst="$(echo $pst | sed "s,\x1B(B\|\x0F,,g")"

    # Remove escape sequences
    local op="$(printf "%q" "$_LP_OPEN_ESC")"
    local cl="$(printf "%q" "$_LP_CLOSE_ESC")"
    pst="$(echo $pst | sed -r "s,$op|$cl,,g")"

    echo -n "$pst"
}

_lp_title()
{
    [[ "$LP_ENABLE_TITLE" != "1" ]] && return

    # Get the current computed prompt as pure text
    local txt="$(_lp_as_text "$1")"

    # Use it in the window's title
    # Escapes whill tells bash to ignore the non-printing control characters when calculating the width of the prompt.
    # Otherwise line editing commands will mess the cursor positionning
    case "$TERM" in
        screen*)
            [[ "$LP_ENABLE_SCREEN_TITLE" != "1" ]] && return
            local title="${_LP_OPEN_ESC}${LP_SCREEN_TITLE_OPEN}${txt}${LP_SCREEN_TITLE_CLOSE}${_LP_CLOSE_ESC}"
            ;;
        linux*)
            local title=""
            ;;
        *)
            local title="${_LP_OPEN_ESC}${LP_TITLE_OPEN}${txt}${LP_TITLE_CLOSE}${_LP_CLOSE_ESC}"
            ;;
    esac
    echo -n "${title}"
}

# Set the prompt mark to ± if git, to ☿ if mercurial, to ‡ if subversion
# to # if root and else $
_lp_smart_mark()
{
    local mark
    case "$LP_VCS_TYPE" in
        git     ) mark="$LP_MARK_GIT"      ;;
        disabled) mark="$LP_MARK_DISABLED" ;;
        *       ) mark="$_LP_MARK_SYMBOL"  ;;
    esac
    echo -ne "${LP_COLOR_MARK}${mark}${NO_COL}"
}

# insert a space on the right
_lp_sr()
{
    [[ -n "$1" ]] && echo -n "$1 "
}

# insert a space on the left
_lp_sl()
{
    [[ -n "$1" ]] && echo -n " $1"
}

# insert two space, before and after
_lp_sb()
{
    [[ -n "$1" ]] && echo -n " $1 "
}


###################
# CURRENT TIME    #
###################
_lp_time()
{
    [[ "$LP_ENABLE_TIME" != 1 ]] && return
    echo -n "${LP_COLOR_TIME}${_LP_TIME_SYMBOL}${NO_COL}"
}


########################
# Construct the prompt #
########################

_lp_set_prompt()
{
    # Display the return value of the last command, if different from zero
    # As this get the last returned code, it should be called first
    local -i err=$?
    if (( err != 0 )); then
        LP_ERR=" $LP_COLOR_ERR$err$NO_COL"
    else
        LP_ERR=     # Hidden
    fi

    # Reset IFS to its default value to avoid strange behaviors
    # (in case the user is playing with the value at the prompt)
    local IFS="$(echo -e ' \t\n')" # space, tab, LF

    # left of main prompt: space at right
    LP_JOBS="$(_lp_sr "$(_lp_jobcount_color)")"
    LP_TIME="$(_lp_sr "$(_lp_time)")"

    # in main prompt: no space
    if [[ "$LP_ENABLE_PROXY,$http_proxy" = 1,?* ]] ; then
        LP_PROXY="$LP_COLOR_PROXY$LP_MARK_PROXY$NO_COL"
    else
        LP_PROXY=
    fi

    # right of main prompt: space at left
    LP_VENV="$(_lp_sl "$(_lp_virtualenv)")"
    # if change of working directory
    if [[ "$LP_OLD_PWD" != "LP:$PWD" ]]; then
        LP_VCS=""
        LP_VCS_TYPE=""
        # LP_HOST is a global set at load time
        LP_PERM="$(_lp_permissions_color)"
        LP_PWD="$(_lp_shorten_path)"

        if _lp_are_vcs_enabled; then
            LP_VCS="$(_lp_git_branch_color)"
            LP_VCS_TYPE="git"
            if [[ -z "$LP_VCS" ]]; then
                LP_VCS=""
                LP_VCS_TYPE=""
            fi # nothing
        else # if this vcs rep is disabled
            LP_VCS="" # not necessary, but more readable
            LP_VCS_TYPE="disabled"
        fi

        if [[ -z "$LP_VCS_TYPE" ]] ; then
            LP_VCS=""
        else
            LP_VCS="$(_lp_sl "${LP_VCS}")"
        fi

        # end of the prompt line: double spaces
        LP_MARK="$(_lp_smart_mark $LP_VCS_TYPE)"

        # The color is different if user is root
        LP_PWD="${LP_COLOR_PATH}${LP_PWD}${NO_COL}"

        LP_OLD_PWD="LP:$PWD"

    # if do not change of working directory but...
    elif [[ -n "$LP_VCS_TYPE" ]]; then # we are still in a VCS dir
        case "$LP_VCS_TYPE" in
            git     ) LP_VCS="$(_lp_sl "$(_lp_git_branch_color)")";;
            disabled) LP_VCS="";;
        esac
    fi

    # add title escape time and jobs
    PS1="${LP_PS1_PREFIX}${LP_TIME}${LP_JOBS}"
    LP_TITLE="${LP_PS1_PREFIX}"
    # add user, host and permissions colon
    PS1="${PS1}${LP_BRACKET_OPEN}${LP_USER}${LP_HOST}${LP_PERM}"
    LP_TITLE="${LP_TITLE}${LP_BRACKET_OPEN}${LP_USER}${LP_HOST}${LP_PERM}"

    PS1="${PS1}${LP_PWD}${LP_BRACKET_CLOSE}${LP_VENV}${LP_PROXY}"
    LP_TITLE="${LP_TITLE}${LP_PWD}${LP_BRACKET_CLOSE}${LP_VENV}"

    # Add VCS infos
    # If root, the info has not been collected unless LP_ENABLE_VCS_ROOT
    # is set.
    PS1="${PS1}${LP_VCS}"

    # add return code and prompt mark
    PS1="${PS1}${LP_ERR}${LP_MARK_PREFIX}${LP_MARK}${LP_PS1_POSTFIX}"
    LP_TITLE="${LP_TITLE} ${LP_MARK}"

    # "invisible" parts
    # Get the current prompt on the fly and make it a title
    LP_TITLE="$(_lp_title "$LP_TITLE")"

    # Insert it in the prompt
    PS1="${LP_TITLE}${PS1}"
}

prompt_tag()
{
    export LP_PS1_PREFIX="$(_lp_sr "$1")"
}

# Activate the liquid prompt
prompt_on()
{
    # if liquidprompt has not been already set
    if [[ -z "$LP_LIQUIDPROMPT" ]]; then
        LP_OLD_PS1="$PS1"
        if $_LP_SHELL_bash; then
            LP_OLD_PROMPT_COMMAND="$PROMPT_COMMAND"
        else # zsh
            LP_OLD_PROMPT_COMMAND="$precmd"
        fi
    fi
    if $_LP_SHELL_bash; then
        PROMPT_COMMAND=_lp_set_prompt
    else # zsh
        function precmd {
            _lp_set_prompt
        }
    fi

    # Keep in mind that LP has been sourced
    # (to avoid recursive prompt command).
    LP_LIQUIDPROMPT=1
}

# Come back to the old prompt
prompt_off()
{
    PS1=$LP_OLD_PS1
    if $_LP_SHELL_bash; then
        PROMPT_COMMAND=$LP_OLD_PROMPT_COMMAND
    else # zsh
        if [[ -n "$LP_OLD_PROMPT_COMMAND" ]]; then
            precmd=$LP_OLD_PROMPT_COMMAND
        else
            function precmd { : ; }
        fi
    fi
}

# Use an empty prompt: just the \$ mark
prompt_OFF()
{
    PS1="\$ "
    if $_LP_SHELL_bash; then
        PROMPT_COMMAND=$LP_OLD_PROMPT_COMMAND
    else # zsh
        if [[ -n "$LP_OLD_PROMPT_COMMAND" ]]; then
            precmd=$LP_OLD_PROMPT_COMMAND
        else
            function precmd { : ; }
        fi
    fi
}

# By default, sourcing liquidprompt will activate the liquid prompt
prompt_on

# vim: set et sts=4 sw=4 tw=120 ft=sh:
